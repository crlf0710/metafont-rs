//! @ Finally, we have only the ``message'' commands remaining.
//!
//! @d message_code=0
//! @d err_message_code=1
//! @d err_help_code=2
//!
//! @<Put each...@>=
//! primitive("message",message_command,message_code);@/
//! @!@:message_}{\&{message} primitive@>
//! primitive("errmessage",message_command,err_message_code);@/
//! @!@:err_message_}{\&{errmessage} primitive@>
//! primitive("errhelp",message_command,err_help_code);@/
//! @!@:err_help_}{\&{errhelp} primitive@>
//!
//! @ @<Cases of |print_cmd...@>=
//! message_command: if m<err_message_code then print("message")
//!   else if m=err_message_code then print("errmessage")
//!   else print("errhelp");
//!
//! @ @<Cases of |do_statement|...@>=
//! message_command: do_message;
//!
//! @ @<Declare action procedures for use by |do_statement|@>=
//! procedure do_message;
//! var @!m:message_code..err_help_code; {the type of message}
//! begin m:=cur_mod; get_x_next; scan_expression;
//! if cur_type<>string_type then
//!   begin exp_err("Not a string");
//! @.Not a string@>
//!   help1("A message should be a known string expression.");
//!   put_get_error;
//!   end
//! else  case m of
//!   message_code:begin print_nl(""); slow_print(cur_exp);
//!     end;
//!   err_message_code:@<Print string |cur_exp| as an error message@>;
//!   err_help_code:@<Save string |cur_exp| as the |err_help|@>;
//!   end; {there are no other cases}
//! flush_cur_exp(0);
//! end;
//!
//! @ The global variable |err_help| is zero when the user has most recently
//! given an empty help string, or if none has ever been given.
//!
//! @<Save string |cur_exp| as the |err_help|@>=
//! begin if err_help<>0 then delete_str_ref(err_help);
//! if length(cur_exp)=0 then err_help:=0
//! else  begin err_help:=cur_exp; add_str_ref(err_help);
//!   end;
//! end
//!
//! @ If \&{errmessage} occurs often in |scroll_mode|, without user-defined
//! \&{errhelp}, we don't want to give a long help message each time. So we
//! give a verbose explanation only once.
//!
//! @<Glob...@>=
//! @!long_help_seen:boolean; {has the long \&{errmessage} help been used?}
//!
//! @ @<Set init...@>=long_help_seen:=false;
//!
//! @ @<Print string |cur_exp| as an error message@>=
//! begin print_err(""); slow_print(cur_exp);
//! if err_help<>0 then use_err_help:=true
//! else if long_help_seen then help1("(That was another `errmessage'.)")
//! else  begin if interaction<error_stop_mode then long_help_seen:=true;
//!   help4("This error message was generated by an `errmessage'")@/
//!   ("command, so I can't give any explicit help.")@/
//!   ("Pretend that you're Miss Marple: Examine all clues,")@/
//! @^Marple, Jane@>
//!   ("and deduce the truth by inspired guesses.");
//!   end;
//! put_get_error; use_err_help:=false;
//! end
//!
//! @* \[45] Font metric data.
//! \TeX\ gets its knowledge about fonts from font metric files, also called
//! \.{TFM} files; the `\.T' in `\.{TFM}' stands for \TeX,
//! but other programs know about them too. One of \MF's duties is to
//! write \.{TFM} files so that the user's fonts can readily be
//! applied to typesetting.
//! @:TFM files}{\.{TFM} files@>
//! @^font metric files@>
//!
//! The information in a \.{TFM} file appears in a sequence of 8-bit bytes.
//! Since the number of bytes is always a multiple of~4, we could
//! also regard the file as a sequence of 32-bit words, but \MF\ uses the
//! byte interpretation. The format of \.{TFM} files was designed by
//! Lyle Ramshaw in 1980. The intent is to convey a lot of different kinds
//! @^Ramshaw, Lyle Harold@>
//! of information in a compact but useful form.
//!
//! @<Glob...@>=
//! @!tfm_file:byte_file; {the font metric output goes here}
//! @!metric_file_name: str_number; {full name of the font metric file}
//!
//! @ The first 24 bytes (6 words) of a \.{TFM} file contain twelve 16-bit
//! integers that give the lengths of the various subsequent portions
//! of the file. These twelve integers are, in order:
//! $$\vbox{\halign{\hfil#&$\null=\null$#\hfil\cr
//! |lf|&length of the entire file, in words;\cr
//! |lh|&length of the header data, in words;\cr
//! |bc|&smallest character code in the font;\cr
//! |ec|&largest character code in the font;\cr
//! |nw|&number of words in the width table;\cr
//! |nh|&number of words in the height table;\cr
//! |nd|&number of words in the depth table;\cr
//! |ni|&number of words in the italic correction table;\cr
//! |nl|&number of words in the lig/kern table;\cr
//! |nk|&number of words in the kern table;\cr
//! |ne|&number of words in the extensible character table;\cr
//! |np|&number of font parameter words.\cr}}$$
//! They are all nonnegative and less than $2^{15}$. We must have |bc-1<=ec<=255|,
//! |ne<=256|, and
//! $$\hbox{|lf=6+lh+(ec-bc+1)+nw+nh+nd+ni+nl+nk+ne+np|.}$$
//! Note that a font may contain as many as 256 characters (if |bc=0| and |ec=255|),
//! and as few as 0 characters (if |bc=ec+1|).
//!
//! Incidentally, when two or more 8-bit bytes are combined to form an integer of
//! 16 or more bits, the most significant bytes appear first in the file.
//! This is called BigEndian order.
//! @!@^BigEndian order@>
//!
//! @ The rest of the \.{TFM} file may be regarded as a sequence of ten data
//! arrays having the informal specification
//! $$\def\arr$[#1]#2${\&{array} $[#1]$ \&{of} #2}
//! \tabskip\centering
//! \halign to\displaywidth{\hfil\\{#}\tabskip=0pt&$\,:\,$\arr#\hfil
//!  \tabskip\centering\cr
//! header&|[0..lh-1]@t\\{stuff}@>|\cr
//! char\_info&|[bc..ec]char_info_word|\cr
//! width&|[0..nw-1]fix_word|\cr
//! height&|[0..nh-1]fix_word|\cr
//! depth&|[0..nd-1]fix_word|\cr
//! italic&|[0..ni-1]fix_word|\cr
//! lig\_kern&|[0..nl-1]lig_kern_command|\cr
//! kern&|[0..nk-1]fix_word|\cr
//! exten&|[0..ne-1]extensible_recipe|\cr
//! param&|[1..np]fix_word|\cr}$$
//! The most important data type used here is a |@!fix_word|, which is
//! a 32-bit representation of a binary fraction. A |fix_word| is a signed
//! quantity, with the two's complement of the entire word used to represent
//! negation. Of the 32 bits in a |fix_word|, exactly 12 are to the left of the
//! binary point; thus, the largest |fix_word| value is $2048-2^{-20}$, and
//! the smallest is $-2048$. We will see below, however, that all but two of
//! the |fix_word| values must lie between $-16$ and $+16$.
//!
//! @ The first data array is a block of header information, which contains
//! general facts about the font. The header must contain at least two words,
//! |header[0]| and |header[1]|, whose meaning is explained below.  Additional
//! header information of use to other software routines might also be
//! included, and \MF\ will generate it if the \.{headerbyte} command occurs.
//! For example, 16 more words of header information are in use at the Xerox
//! Palo Alto Research Center; the first ten specify the character coding
//! scheme used (e.g., `\.{XEROX TEXT}' or `\.{TEX MATHSY}'), the next five
//! give the font family name (e.g., `\.{HELVETICA}' or `\.{CMSY}'), and the
//! last gives the ``face byte.''
//!
//! \yskip\hang|header[0]| is a 32-bit check sum that \MF\ will copy into
//! the \.{GF} output file. This helps ensure consistency between files,
//! since \TeX\ records the check sums from the \.{TFM}'s it reads, and these
//! should match the check sums on actual fonts that are used.  The actual
//! relation between this check sum and the rest of the \.{TFM} file is not
//! important; the check sum is simply an identification number with the
//! property that incompatible fonts almost always have distinct check sums.
//! @^check sum@>
//!
//! \yskip\hang|header[1]| is a |fix_word| containing the design size of the
//! font, in units of \TeX\ points. This number must be at least 1.0; it is
//! fairly arbitrary, but usually the design size is 10.0 for a ``10 point''
//! font, i.e., a font that was designed to look best at a 10-point size,
//! whatever that really means. When a \TeX\ user asks for a font `\.{at}
//! $\delta$ \.{pt}', the effect is to override the design size and replace it
//! by $\delta$, and to multiply the $x$ and~$y$ coordinates of the points in
//! the font image by a factor of $\delta$ divided by the design size.  {\sl
//! All other dimensions in the\/ \.{TFM} file are |fix_word|\kern-1pt\
//! numbers in design-size units.} Thus, for example, the value of |param[6]|,
//! which defines the \.{em} unit, is often the |fix_word| value $2^{20}=1.0$,
//! since many fonts have a design size equal to one em.  The other dimensions
//! must be less than 16 design-size units in absolute value; thus,
//! |header[1]| and |param[1]| are the only |fix_word| entries in the whole
//! \.{TFM} file whose first byte might be something besides 0 or 255.
//! @^design size@>
//!
//! @ Next comes the |char_info| array, which contains one |@!char_info_word|
//! per character. Each word in this part of the file contains six fields
//! packed into four bytes as follows.
//!
//! \yskip\hang first byte: |@!width_index| (8 bits)\par
//! \hang second byte: |@!height_index| (4 bits) times 16, plus |@!depth_index|
//!   (4~bits)\par
//! \hang third byte: |@!italic_index| (6 bits) times 4, plus |@!tag|
//!   (2~bits)\par
//! \hang fourth byte: |@!remainder| (8 bits)\par
//! \yskip\noindent
//! The actual width of a character is \\{width}|[width_index]|, in design-size
//! units; this is a device for compressing information, since many characters
//! have the same width. Since it is quite common for many characters
//! to have the same height, depth, or italic correction, the \.{TFM} format
//! imposes a limit of 16 different heights, 16 different depths, and
//! 64 different italic corrections.
//!
//! Incidentally, the relation $\\{width}[0]=\\{height}[0]=\\{depth}[0]=
//! \\{italic}[0]=0$ should always hold, so that an index of zero implies a
//! value of zero.  The |width_index| should never be zero unless the
//! character does not exist in the font, since a character is valid if and
//! only if it lies between |bc| and |ec| and has a nonzero |width_index|.
//!
//! @ The |tag| field in a |char_info_word| has four values that explain how to
//! interpret the |remainder| field.
//!
//! \def\hangg#1 {\hang\hbox{#1 }}
//! \yskip\hangg|tag=0| (|no_tag|) means that |remainder| is unused.\par
//! \hangg|tag=1| (|lig_tag|) means that this character has a ligature/kerning
//! program starting at location |remainder| in the |lig_kern| array.\par
//! \hangg|tag=2| (|list_tag|) means that this character is part of a chain of
//! characters of ascending sizes, and not the largest in the chain.  The
//! |remainder| field gives the character code of the next larger character.\par
//! \hangg|tag=3| (|ext_tag|) means that this character code represents an
//! extensible character, i.e., a character that is built up of smaller pieces
//! so that it can be made arbitrarily large. The pieces are specified in
//! |@!exten[remainder]|.\par
//! \yskip\noindent
//! Characters with |tag=2| and |tag=3| are treated as characters with |tag=0|
//! unless they are used in special circumstances in math formulas. For example,
//! \TeX's \.{\\sum} operation looks for a |list_tag|, and the \.{\\left}
//! operation looks for both |list_tag| and |ext_tag|.
//!
//! @d no_tag=0 {vanilla character}
//! @d lig_tag=1 {character has a ligature/kerning program}
//! @d list_tag=2 {character has a successor in a charlist}
//! @d ext_tag=3 {character is extensible}
//!
//! @ The |lig_kern| array contains instructions in a simple programming language
//! that explains what to do for special letter pairs. Each word in this array is a
//! |@!lig_kern_command| of four bytes.
//!
//! \yskip\hang first byte: |skip_byte|, indicates that this is the final program
//!   step if the byte is 128 or more, otherwise the next step is obtained by
//!   skipping this number of intervening steps.\par
//! \hang second byte: |next_char|, ``if |next_char| follows the current character,
//!   then perform the operation and stop, otherwise continue.''\par
//! \hang third byte: |op_byte|, indicates a ligature step if less than~128,
//!   a kern step otherwise.\par
//! \hang fourth byte: |remainder|.\par
//! \yskip\noindent
//! In a kern step, an
//! additional space equal to |kern[256*(op_byte-128)+remainder]| is inserted
//! between the current character and |next_char|. This amount is
//! often negative, so that the characters are brought closer together
//! by kerning; but it might be positive.
//!
//! There are eight kinds of ligature steps, having |op_byte| codes $4a+2b+c$ where
//! $0\le a\le b+c$ and $0\le b,c\le1$. The character whose code is
//! |remainder| is inserted between the current character and |next_char|;
//! then the current character is deleted if $b=0$, and |next_char| is
//! deleted if $c=0$; then we pass over $a$~characters to reach the next
//! current character (which may have a ligature/kerning program of its own).
//!
//! If the very first instruction of the |lig_kern| array has |skip_byte=255|,
//! the |next_char| byte is the so-called boundary character of this font;
//! the value of |next_char| need not lie between |bc| and~|ec|.
//! If the very last instruction of the |lig_kern| array has |skip_byte=255|,
//! there is a special ligature/kerning program for a boundary character at the
//! left, beginning at location |256*op_byte+remainder|.
//! The interpretation is that \TeX\ puts implicit boundary characters
//! before and after each consecutive string of characters from the same font.
//! These implicit characters do not appear in the output, but they can affect
//! ligatures and kerning.
//!
//! If the very first instruction of a character's |lig_kern| program has
//! |skip_byte>128|, the program actually begins in location
//! |256*op_byte+remainder|. This feature allows access to large |lig_kern|
//! arrays, because the first instruction must otherwise
//! appear in a location |<=255|.
//!
//! Any instruction with |skip_byte>128| in the |lig_kern| array must satisfy
//! the condition
//! $$\hbox{|256*op_byte+remainder<nl|.}$$
//! If such an instruction is encountered during
//! normal program execution, it denotes an unconditional halt; no ligature
//! or kerning command is performed.
//!
//! @d stop_flag=128+min_quarterword
//!   {value indicating `\.{STOP}' in a lig/kern program}
//! @d kern_flag=128+min_quarterword {op code for a kern step}
//! @d skip_byte(#)==lig_kern[#].b0
//! @d next_char(#)==lig_kern[#].b1
//! @d op_byte(#)==lig_kern[#].b2
//! @d rem_byte(#)==lig_kern[#].b3
//!
//! @ Extensible characters are specified by an |@!extensible_recipe|, which
//! consists of four bytes called |@!top|, |@!mid|, |@!bot|, and |@!rep| (in this
//! order). These bytes are the character codes of individual pieces used to
//! build up a large symbol.  If |top|, |mid|, or |bot| are zero, they are not
//! present in the built-up result. For example, an extensible vertical line is
//! like an extensible bracket, except that the top and bottom pieces are missing.
//!
//! Let $T$, $M$, $B$, and $R$ denote the respective pieces, or an empty box
//! if the piece isn't present. Then the extensible characters have the form
//! $TR^kMR^kB$ from top to bottom, for some |k>=0|, unless $M$ is absent;
//! in the latter case we can have $TR^kB$ for both even and odd values of~|k|.
//! The width of the extensible character is the width of $R$; and the
//! height-plus-depth is the sum of the individual height-plus-depths of the
//! components used, since the pieces are butted together in a vertical list.
//!
//! @d ext_top(#)==exten[#].b0 {|top| piece in a recipe}
//! @d ext_mid(#)==exten[#].b1 {|mid| piece in a recipe}
//! @d ext_bot(#)==exten[#].b2 {|bot| piece in a recipe}
//! @d ext_rep(#)==exten[#].b3 {|rep| piece in a recipe}
//!
//! @ The final portion of a \.{TFM} file is the |param| array, which is another
//! sequence of |fix_word| values.
//!
//! \yskip\hang|param[1]=slant| is the amount of italic slant, which is used
//! to help position accents. For example, |slant=.25| means that when you go
//! up one unit, you also go .25 units to the right. The |slant| is a pure
//! number; it is the only |fix_word| other than the design size itself that is
//! not scaled by the design size.
//! @^design size@>
//!
//! \hang|param[2]=space| is the normal spacing between words in text.
//! Note that character @'40 in the font need not have anything to do with
//! blank spaces.
//!
//! \hang|param[3]=space_stretch| is the amount of glue stretching between words.
//!
//! \hang|param[4]=space_shrink| is the amount of glue shrinking between words.
//!
//! \hang|param[5]=x_height| is the size of one ex in the font; it is also
//! the height of letters for which accents don't have to be raised or lowered.
//!
//! \hang|param[6]=quad| is the size of one em in the font.
//!
//! \hang|param[7]=extra_space| is the amount added to |param[2]| at the
//! ends of sentences.
//!
//! \yskip\noindent
//! If fewer than seven parameters are present, \TeX\ sets the missing parameters
//! to zero.
//!
//! @d slant_code=1
//! @d space_code=2
//! @d space_stretch_code=3
//! @d space_shrink_code=4
//! @d x_height_code=5
//! @d quad_code=6
//! @d extra_space_code=7
//!
//! @ So that is what \.{TFM} files hold. One of \MF's duties is to output such
//! information, and it does this all at once at the end of a job.
//! In order to prepare for such frenetic activity, it squirrels away the
//! necessary facts in various arrays as information becomes available.
//!
//! Character dimensions (\&{charwd}, \&{charht}, \&{chardp}, and \&{charic})
//! are stored respectively in |tfm_width|, |tfm_height|, |tfm_depth|, and
//! |tfm_ital_corr|. Other information about a character (e.g., about
//! its ligatures or successors) is accessible via the |char_tag| and
//! |char_remainder| arrays. Other information about the font as a whole
//! is kept in additional arrays called |header_byte|, |lig_kern|,
//! |kern|, |exten|, and |param|.
//!
//! @d undefined_label==lig_table_size {an undefined local label}
//!
//! @<Glob...@>=
//! @!bc,@!ec:eight_bits; {smallest and largest character codes shipped out}
//! @!tfm_width:array[eight_bits] of scaled; {\&{charwd} values}
//! @!tfm_height:array[eight_bits] of scaled; {\&{charht} values}
//! @!tfm_depth:array[eight_bits] of scaled; {\&{chardp} values}
//! @!tfm_ital_corr:array[eight_bits] of scaled; {\&{charic} values}
//! @!char_exists:array[eight_bits] of boolean; {has this code been shipped out?}
//! @!char_tag:array[eight_bits] of no_tag..ext_tag; {|remainder| category}
//! @!char_remainder:array[eight_bits] of 0..lig_table_size; {the |remainder| byte}
//! @!header_byte:array[1..header_size] of -1..255;
//!   {bytes of the \.{TFM} header, or $-1$ if unset}
//! @!lig_kern:array[0..lig_table_size] of four_quarters; {the ligature/kern table}
//! @!nl:0..32767-256; {the number of ligature/kern steps so far}
//! @!kern:array[0..max_kerns] of scaled; {distinct kerning amounts}
//! @!nk:0..max_kerns; {the number of distinct kerns so far}
//! @!exten:array[eight_bits] of four_quarters; {extensible character recipes}
//! @!ne:0..256; {the number of extensible characters so far}
//! @!param:array[1..max_font_dimen] of scaled; {\&{fontdimen} parameters}
//! @!np:0..max_font_dimen; {the largest \&{fontdimen} parameter specified so far}
//! @!nw,@!nh,@!nd,@!ni:0..256; {sizes of \.{TFM} subtables}
//! @!skip_table:array[eight_bits] of 0..lig_table_size; {local label status}
//! @!lk_started:boolean; {has there been a lig/kern step in this command yet?}
//! @!bchar:integer; {right boundary character}
//! @!bch_label:0..lig_table_size; {left boundary starting location}
//! @!ll,@!lll:0..lig_table_size; {registers used for lig/kern processing}
//! @!label_loc:array[0..256] of -1..lig_table_size; {lig/kern starting addresses}
//! @!label_char:array[1..256] of eight_bits; {characters for |label_loc|}
//! @!label_ptr:0..256; {highest position occupied in |label_loc|}
//!
//! @ @<Set init...@>=
//! for k:=0 to 255 do
//!   begin tfm_width[k]:=0; tfm_height[k]:=0; tfm_depth[k]:=0; tfm_ital_corr[k]:=0;
//!   char_exists[k]:=false; char_tag[k]:=no_tag; char_remainder[k]:=0;
//!   skip_table[k]:=undefined_label;
//!   end;
//! for k:=1 to header_size do header_byte[k]:=-1;
//! bc:=255; ec:=0; nl:=0; nk:=0; ne:=0; np:=0;@/
//! internal[boundary_char]:=-unity;
//! bch_label:=undefined_label;@/
//! label_loc[0]:=-1; label_ptr:=0;
//!
//! @ @<Declare the function called |tfm_check|@>=
//! function tfm_check(@!m:small_number):scaled;
//! begin if abs(internal[m])>=fraction_half then
//!   begin print_err("Enormous "); print(int_name[m]);
//! @.Enormous charwd...@>
//! @.Enormous chardp...@>
//! @.Enormous charht...@>
//! @.Enormous charic...@>
//! @.Enormous designsize...@>
//!   print(" has been reduced");
//!   help1("Font metric dimensions must be less than 2048pt.");
//!   put_get_error;
//!   if internal[m]>0 then tfm_check:=fraction_half-1
//!   else tfm_check:=1-fraction_half;
//!   end
//! else tfm_check:=internal[m];
//! end;
//!
//! @ @<Store the width information for character code~|c|@>=
//! if c<bc then bc:=c;
//! if c>ec then ec:=c;
//! char_exists[c]:=true;
//! gf_dx[c]:=internal[char_dx]; gf_dy[c]:=internal[char_dy];
//! tfm_width[c]:=tfm_check(char_wd);
//! tfm_height[c]:=tfm_check(char_ht);
//! tfm_depth[c]:=tfm_check(char_dp);
//! tfm_ital_corr[c]:=tfm_check(char_ic)
//!
//! @ Now let's consider \MF's special \.{TFM}-oriented commands.
//!
//! @<Cases of |do_statement|...@>=
//! tfm_command: do_tfm_command;
//!
//! @ @d char_list_code=0
//! @d lig_table_code=1
//! @d extensible_code=2
//! @d header_byte_code=3
//! @d font_dimen_code=4
//!
//! @<Put each...@>=
//! primitive("charlist",tfm_command,char_list_code);@/
//! @!@:char_list_}{\&{charlist} primitive@>
//! primitive("ligtable",tfm_command,lig_table_code);@/
//! @!@:lig_table_}{\&{ligtable} primitive@>
//! primitive("extensible",tfm_command,extensible_code);@/
//! @!@:extensible_}{\&{extensible} primitive@>
//! primitive("headerbyte",tfm_command,header_byte_code);@/
//! @!@:header_byte_}{\&{headerbyte} primitive@>
//! primitive("fontdimen",tfm_command,font_dimen_code);@/
//! @!@:font_dimen_}{\&{fontdimen} primitive@>
//!
//! @ @<Cases of |print_cmd...@>=
//! tfm_command: case m of
//!   char_list_code:print("charlist");
//!   lig_table_code:print("ligtable");
//!   extensible_code:print("extensible");
//!   header_byte_code:print("headerbyte");
//!   othercases print("fontdimen")
//!   endcases;
//!
//! @ @<Declare action procedures for use by |do_statement|@>=
//! function get_code:eight_bits; {scans a character code value}
//! label found;
//! var @!c:integer; {the code value found}
//! begin get_x_next; scan_expression;
//! if cur_type=known then
//!   begin c:=round_unscaled(cur_exp);
//!   if c>=0 then if c<256 then goto found;
//!   end
//! else if cur_type=string_type then if length(cur_exp)=1 then
//!   begin c:=so(str_pool[str_start[cur_exp]]); goto found;
//!   end;
//! exp_err("Invalid code has been replaced by 0");
//! @.Invalid code...@>
//! help2("I was looking for a number between 0 and 255, or for a")@/
//!   ("string of length 1. Didn't find it; will use 0 instead.");
//! put_get_flush_error(0); c:=0;
//! found: get_code:=c;
//! end;
//!
//! @ @<Declare action procedures for use by |do_statement|@>=
//! procedure set_tag(@!c:halfword;@!t:small_number;@!r:halfword);
//! begin if char_tag[c]=no_tag then
//!   begin char_tag[c]:=t; char_remainder[c]:=r;
//!   if t=lig_tag then
//!     begin incr(label_ptr); label_loc[label_ptr]:=r; label_char[label_ptr]:=c;
//!     end;
//!   end
//! else @<Complain about a character tag conflict@>;
//! end;
//!
//! @ @<Complain about a character tag conflict@>=
//! begin print_err("Character ");
//! if (c>" ")and(c<127) then print(c)
//! else if c=256 then print("||")
//! else  begin print("code "); print_int(c);
//!   end;
//! print(" is already ");
//! @.Character c is already...@>
//! case char_tag[c] of
//! lig_tag: print("in a ligtable");
//! list_tag: print("in a charlist");
//! ext_tag: print("extensible");
//! end; {there are no other cases}
//! help2("It's not legal to label a character more than once.")@/
//!   ("So I'll not change anything just now.");
//! put_get_error; end
//!
//! @ @<Declare action procedures for use by |do_statement|@>=
//! procedure do_tfm_command;
//! label continue,done;
//! var @!c,@!cc:0..256; {character codes}
//! @!k:0..max_kerns; {index into the |kern| array}
//! @!j:integer; {index into |header_byte| or |param|}
//! begin case cur_mod of
//! char_list_code: begin c:=get_code;
//!      {we will store a list of character successors}
//!   while cur_cmd=colon do
//!     begin cc:=get_code; set_tag(c,list_tag,cc); c:=cc;
//!     end;
//!   end;
//! lig_table_code: @<Store a list of ligature/kern steps@>;
//! extensible_code: @<Define an extensible recipe@>;
//! header_byte_code, font_dimen_code: begin c:=cur_mod; get_x_next;
//!   scan_expression;
//!   if (cur_type<>known)or(cur_exp<half_unit) then
//!     begin exp_err("Improper location");
//! @.Improper location@>
//!     help2("I was looking for a known, positive number.")@/
//!       ("For safety's sake I'll ignore the present command.");
//!     put_get_error;
//!     end
//!   else  begin j:=round_unscaled(cur_exp);
//!     if cur_cmd<>colon then
//!       begin missing_err(":");
//! @.Missing `:'@>
//!       help1("A colon should follow a headerbyte or fontdimen location.");
//!       back_error;
//!       end;
//!     if c=header_byte_code then @<Store a list of header bytes@>
//!     else @<Store a list of font dimensions@>;
//!     end;
//!   end;
//! end; {there are no other cases}
//! end;
//!
//! @ @<Store a list of ligature/kern steps@>=
//! begin lk_started:=false;
//! continue: get_x_next;
//! if(cur_cmd=skip_to)and lk_started then
//!  @<Process a |skip_to| command and |goto done|@>;
//! if cur_cmd=bchar_label then
//!   begin c:=256; cur_cmd:=colon;@+end
//! else begin back_input; c:=get_code;@+end;
//! if(cur_cmd=colon)or(cur_cmd=double_colon)then
//!   @<Record a label in a lig/kern subprogram and |goto continue|@>;
//! if cur_cmd=lig_kern_token then @<Compile a ligature/kern command@>
//! else  begin print_err("Illegal ligtable step");
//! @.Illegal ligtable step@>
//!   help1("I was looking for `=:' or `kern' here.");
//!   back_error; next_char(nl):=qi(0); op_byte(nl):=qi(0); rem_byte(nl):=qi(0);@/
//!   skip_byte(nl):=stop_flag+1; {this specifies an unconditional stop}
//!   end;
//! if nl=lig_table_size then overflow("ligtable size",lig_table_size);
//! @:METAFONT capacity exceeded ligtable size}{\quad ligtable size@>
//! incr(nl);
//! if cur_cmd=comma then goto continue;
//! if skip_byte(nl-1)<stop_flag then skip_byte(nl-1):=stop_flag;
//! done:end
//!
//! @ @<Put each...@>=
//! primitive("=:",lig_kern_token,0);
//! @!@:=:_}{\.{=:} primitive@>
//! primitive("=:|",lig_kern_token,1);
//! @!@:=:/_}{\.{=:\char'174} primitive@>
//! primitive("=:|>",lig_kern_token,5);
//! @!@:=:/>_}{\.{=:\char'174>} primitive@>
//! primitive("|=:",lig_kern_token,2);
//! @!@:=:/_}{\.{\char'174=:} primitive@>
//! primitive("|=:>",lig_kern_token,6);
//! @!@:=:/>_}{\.{\char'174=:>} primitive@>
//! primitive("|=:|",lig_kern_token,3);
//! @!@:=:/_}{\.{\char'174=:\char'174} primitive@>
//! primitive("|=:|>",lig_kern_token,7);
//! @!@:=:/>_}{\.{\char'174=:\char'174>} primitive@>
//! primitive("|=:|>>",lig_kern_token,11);
//! @!@:=:/>_}{\.{\char'174=:\char'174>>} primitive@>
//! primitive("kern",lig_kern_token,128);
//! @!@:kern_}{\&{kern} primitive@>
//!
//! @ @<Cases of |print_cmd...@>=
//! lig_kern_token: case m of
//! 0:print("=:");
//! 1:print("=:|");
//! 2:print("|=:");
//! 3:print("|=:|");
//! 5:print("=:|>");
//! 6:print("|=:>");
//! 7:print("|=:|>");
//! 11:print("|=:|>>");
//! othercases print("kern")
//! endcases;
//!
//! @ Local labels are implemented by maintaining the |skip_table| array,
//! where |skip_table[c]| is either |undefined_label| or the address of the
//! most recent lig/kern instruction that skips to local label~|c|. In the
//! latter case, the |skip_byte| in that instruction will (temporarily)
//! be zero if there were no prior skips to this label, or it will be the
//! distance to the prior skip.
//!
//! We may need to cancel skips that span more than 127 lig/kern steps.
//!
//! @d cancel_skips(#)==ll:=#;
//!   repeat lll:=qo(skip_byte(ll)); skip_byte(ll):=stop_flag; ll:=ll-lll;
//!   until lll=0
//! @d skip_error(#)==begin print_err("Too far to skip");
//! @.Too far to skip@>
//!   help1("At most 127 lig/kern steps can separate skipto1 from 1::.");
//!   error; cancel_skips(#);
//!   end
//!
//! @<Process a |skip_to| command and |goto done|@>=
//! begin c:=get_code;
//! if nl-skip_table[c]>128 then
//!   begin skip_error(skip_table[c]); skip_table[c]:=undefined_label;
//!   end;
//! if skip_table[c]=undefined_label then skip_byte(nl-1):=qi(0)
//! else skip_byte(nl-1):=qi(nl-skip_table[c]-1);
//! skip_table[c]:=nl-1; goto done;
//! end
//!
//! @ @<Record a label in a lig/kern subprogram and |goto continue|@>=
//! begin if cur_cmd=colon then
//!   if c=256 then bch_label:=nl
//!   else set_tag(c,lig_tag,nl)
//! else if skip_table[c]<undefined_label then
//!   begin ll:=skip_table[c]; skip_table[c]:=undefined_label;
//!   repeat lll:=qo(skip_byte(ll));
//!   if nl-ll>128 then
//!     begin skip_error(ll); goto continue;
//!     end;
//!   skip_byte(ll):=qi(nl-ll-1); ll:=ll-lll;
//!   until lll=0;
//!   end;
//! goto continue;
//! end
//!
//! @ @<Compile a ligature/kern...@>=
//! begin next_char(nl):=qi(c); skip_byte(nl):=qi(0);
//! if cur_mod<128 then {ligature op}
//!   begin op_byte(nl):=qi(cur_mod); rem_byte(nl):=qi(get_code);
//!   end
//! else  begin get_x_next; scan_expression;
//!   if cur_type<>known then
//!     begin exp_err("Improper kern");
//! @.Improper kern@>
//!     help2("The amount of kern should be a known numeric value.")@/
//!       ("I'm zeroing this one. Proceed, with fingers crossed.");
//!     put_get_flush_error(0);
//!     end;
//!   kern[nk]:=cur_exp;
//!   k:=0;@+while kern[k]<>cur_exp do incr(k);
//!   if k=nk then
//!     begin if nk=max_kerns then overflow("kern",max_kerns);
//! @:METAFONT capacity exceeded kern}{\quad kern@>
//!     incr(nk);
//!     end;
//!   op_byte(nl):=kern_flag+(k div 256);
//!   rem_byte(nl):=qi((k mod 256));
//!   end;
//! lk_started:=true;
//! end
//!
//! @ @d missing_extensible_punctuation(#)==
//!   begin missing_err(#);
//! @.Missing `\char`\#'@>
//!   help1("I'm processing `extensible c: t,m,b,r'."); back_error;
//!   end
//!
//! @<Define an extensible recipe@>=
//! begin if ne=256 then overflow("extensible",256);
//! @:METAFONT capacity exceeded extensible}{\quad extensible@>
//! c:=get_code; set_tag(c,ext_tag,ne);
//! if cur_cmd<>colon then missing_extensible_punctuation(":");
//! ext_top(ne):=qi(get_code);
//! if cur_cmd<>comma then missing_extensible_punctuation(",");
//! ext_mid(ne):=qi(get_code);
//! if cur_cmd<>comma then missing_extensible_punctuation(",");
//! ext_bot(ne):=qi(get_code);
//! if cur_cmd<>comma then missing_extensible_punctuation(",");
//! ext_rep(ne):=qi(get_code);
//! incr(ne);
//! end
//!
//! @ @<Store a list of header bytes@>=
//! repeat if j>header_size then overflow("headerbyte",header_size);
//! @:METAFONT capacity exceeded headerbyte}{\quad headerbyte@>
//! header_byte[j]:=get_code; incr(j);
//! until cur_cmd<>comma
//!
//! @ @<Store a list of font dimensions@>=
//! repeat if j>max_font_dimen then overflow("fontdimen",max_font_dimen);
//! @:METAFONT capacity exceeded fontdimen}{\quad fontdimen@>
//! while j>np do
//!   begin incr(np); param[np]:=0;
//!   end;
//! get_x_next; scan_expression;
//! if cur_type<>known then
//!   begin exp_err("Improper font parameter");
//! @.Improper font parameter@>
//!   help1("I'm zeroing this one. Proceed, with fingers crossed.");
//!   put_get_flush_error(0);
//!   end;
//! param[j]:=cur_exp; incr(j);
//! until cur_cmd<>comma
//!
//! @ OK: We've stored all the data that is needed for the \.{TFM} file.
//! All that remains is to output it in the correct format.
//!
//! An interesting problem needs to be solved in this connection, because
//! the \.{TFM} format allows at most 256~widths, 16~heights, 16~depths,
//! and 64~italic corrections. If the data has more distinct values than
//! this, we want to meet the necessary restrictions by perturbing the
//! given values as little as possible.
//!
//! \MF\ solves this problem in two steps. First the values of a given
//! kind (widths, heights, depths, or italic corrections) are sorted;
//! then the list of sorted values is perturbed, if necessary.
//!
//! The sorting operation is facilitated by having a special node of
//! essentially infinite |value| at the end of the current list.
//!
//! @<Initialize table entries...@>=
//! value(inf_val):=fraction_four;
//!
//! @ Straight linear insertion is good enough for sorting, since the lists
//! are usually not terribly long. As we work on the data, the current list
//! will start at |link(temp_head)| and end at |inf_val|; the nodes in this
//! list will be in increasing order of their |value| fields.
//!
//! Given such a list, the |sort_in| function takes a value and returns a pointer
//! to where that value can be found in the list. The value is inserted in
//! the proper place, if necessary.
//!
//! At the time we need to do these operations, most of \MF's work has been
//! completed, so we will have plenty of memory to play with. The value nodes
//! that are allocated for sorting will never be returned to free storage.
//!
//! @d clear_the_list==link(temp_head):=inf_val
//!
//! @p function sort_in(@!v:scaled):pointer;
//! label found;
//! var @!p,@!q,@!r:pointer; {list manipulation registers}
//! begin p:=temp_head;
//! loop@+  begin q:=link(p);
//!   if v<=value(q) then goto found;
//!   p:=q;
//!   end;
//! found: if v<value(q) then
//!   begin r:=get_node(value_node_size); value(r):=v; link(r):=q; link(p):=r;
//!   end;
//! sort_in:=link(p);
//! end;
//!
//! @ Now we come to the interesting part, where we reduce the list if necessary
//! until it has the required size. The |min_cover| routine is basic to this
//! process; it computes the minimum number~|m| such that the values of the
//! current sorted list can be covered by |m|~intervals of width~|d|. It
//! also sets the global value |perturbation| to the smallest value $d'>d$
//! such that the covering found by this algorithm would be different.
//!
//! In particular, |min_cover(0)| returns the number of distinct values in the
//! current list and sets |perturbation| to the minimum distance between
//! adjacent values.
//!
//! @p function min_cover(@!d:scaled):integer;
//! var @!p:pointer; {runs through the current list}
//! @!l:scaled; {the least element covered by the current interval}
//! @!m:integer; {lower bound on the size of the minimum cover}
//! begin m:=0; p:=link(temp_head); perturbation:=el_gordo;
//! while p<>inf_val do
//!   begin incr(m); l:=value(p);
//!   repeat p:=link(p);
//!   until value(p)>l+d;
//!   if value(p)-l<perturbation then perturbation:=value(p)-l;
//!   end;
//! min_cover:=m;
//! end;
//!
//! @ @<Glob...@>=
//! @!perturbation:scaled; {quantity related to \.{TFM} rounding}
//! @!excess:integer; {the list is this much too long}
//!
//! @ The smallest |d| such that a given list can be covered with |m| intervals
//! is determined by the |threshold| routine, which is sort of an inverse
//! to |min_cover|. The idea is to increase the interval size rapidly until
//! finding the range, then to go sequentially until the exact borderline has
//! been discovered.
//!
//! @p function threshold(@!m:integer):scaled;
//! var @!d:scaled; {lower bound on the smallest interval size}
//! begin excess:=min_cover(0)-m;
//! if excess<=0 then threshold:=0
//! else  begin repeat d:=perturbation;
//!   until min_cover(d+d)<=m;
//!   while min_cover(d)>m do d:=perturbation;
//!   threshold:=d;
//!   end;
//! end;
//!
//! @ The |skimp| procedure reduces the current list to at most |m| entries,
//! by changing values if necessary. It also sets |info(p):=k| if |value(p)|
//! is the |k|th distinct value on the resulting list, and it sets
//! |perturbation| to the maximum amount by which a |value| field has
//! been changed. The size of the resulting list is returned as the
//! value of |skimp|.
//!
//! @p function skimp(@!m:integer):integer;
//! var @!d:scaled; {the size of intervals being coalesced}
//! @!p,@!q,@!r:pointer; {list manipulation registers}
//! @!l:scaled; {the least value in the current interval}
//! @!v:scaled; {a compromise value}
//! begin d:=threshold(m); perturbation:=0;
//! q:=temp_head; m:=0; p:=link(temp_head);
//! while p<>inf_val do
//!   begin incr(m); l:=value(p); info(p):=m;
//!   if value(link(p))<=l+d then
//!     @<Replace an interval of values by its midpoint@>;
//!   q:=p; p:=link(p);
//!   end;
//! skimp:=m;
//! end;
//!
//! @ @<Replace an interval...@>=
//! begin repeat p:=link(p); info(p):=m;
//! decr(excess);@+if excess=0 then d:=0;
//! until value(link(p))>l+d;
//! v:=l+half(value(p)-l);
//! if value(p)-v>perturbation then perturbation:=value(p)-v;
//! r:=q;
//! repeat r:=link(r); value(r):=v;
//! until r=p;
//! link(q):=p; {remove duplicate values from the current list}
//! end
//!
//! @ A warning message is issued whenever something is perturbed by
//! more than 1/16\thinspace pt.
//!
//! @p procedure tfm_warning(@!m:small_number);
//! begin print_nl("(some "); print(int_name[m]);
//! @.some charwds...@>
//! @.some chardps...@>
//! @.some charhts...@>
//! @.some charics...@>
//! print(" values had to be adjusted by as much as ");
//! print_scaled(perturbation); print("pt)");
//! end;
//!
//! @ Here's an example of how we use these routines.
//! The width data needs to be perturbed only if there are 256 distinct
//! widths, but \MF\ must check for this case even though it is
//! highly unusual.
//!
//! An integer variable |k| will be defined when we use this code.
//! The |dimen_head| array will contain pointers to the sorted
//! lists of dimensions.
//!
//! @<Massage the \.{TFM} widths@>=
//! clear_the_list;
//! for k:=bc to ec do if char_exists[k] then
//!   tfm_width[k]:=sort_in(tfm_width[k]);
//! nw:=skimp(255)+1; dimen_head[1]:=link(temp_head);
//! if perturbation>=@'10000 then tfm_warning(char_wd)
//!
//! @ @<Glob...@>=
//! @!dimen_head:array[1..4] of pointer; {lists of \.{TFM} dimensions}
//!
//! @ Heights, depths, and italic corrections are different from widths
//! not only because their list length is more severely restricted, but
//! also because zero values do not need to be put into the lists.
//!
//! @<Massage the \.{TFM} heights, depths, and italic corrections@>=
//! clear_the_list;
//! for k:=bc to ec do if char_exists[k] then
//!   if tfm_height[k]=0 then tfm_height[k]:=zero_val
//!   else tfm_height[k]:=sort_in(tfm_height[k]);
//! nh:=skimp(15)+1; dimen_head[2]:=link(temp_head);
//! if perturbation>=@'10000 then tfm_warning(char_ht);
//! clear_the_list;
//! for k:=bc to ec do if char_exists[k] then
//!   if tfm_depth[k]=0 then tfm_depth[k]:=zero_val
//!   else tfm_depth[k]:=sort_in(tfm_depth[k]);
//! nd:=skimp(15)+1; dimen_head[3]:=link(temp_head);
//! if perturbation>=@'10000 then tfm_warning(char_dp);
//! clear_the_list;
//! for k:=bc to ec do if char_exists[k] then
//!   if tfm_ital_corr[k]=0 then tfm_ital_corr[k]:=zero_val
//!   else tfm_ital_corr[k]:=sort_in(tfm_ital_corr[k]);
//! ni:=skimp(63)+1; dimen_head[4]:=link(temp_head);
//! if perturbation>=@'10000 then tfm_warning(char_ic)
//!
//! @ @<Initialize table entries...@>=
//! value(zero_val):=0; info(zero_val):=0;
//!
//! @ Bytes 5--8 of the header are set to the design size, unless the user has
//! some crazy reason for specifying them differently.
//! @^design size@>
//!
//! Error messages are not allowed at the time this procedure is called,
//! so a warning is printed instead.
//!
//! The value of |max_tfm_dimen| is calculated so that
//! $$\hbox{|make_scaled(16*max_tfm_dimen,internal[design_size])|}
//!  < \\{three\_bytes}.$$
//!
//! @d three_bytes==@'100000000 {$2^{24}$}
//!
//! @p procedure fix_design_size;
//! var @!d:scaled; {the design size}
//! begin d:=internal[design_size];
//! if (d<unity)or(d>=fraction_half) then
//!   begin if d<>0 then
//!     print_nl("(illegal design size has been changed to 128pt)");
//! @.illegal design size...@>
//!   d:=@'40000000; internal[design_size]:=d;
//!   end;
//! if header_byte[5]<0 then if header_byte[6]<0 then
//!   if header_byte[7]<0 then if header_byte[8]<0 then
//!   begin header_byte[5]:=d div @'4000000;
//!   header_byte[6]:=(d div 4096) mod 256;
//!   header_byte[7]:=(d div 16) mod 256;
//!   header_byte[8]:=(d mod 16)*16;
//!   end;
//! max_tfm_dimen:=16*internal[design_size]-1-internal[design_size] div @'10000000;
//! if max_tfm_dimen>=fraction_half then max_tfm_dimen:=fraction_half-1;
//! end;
//!
//! @ The |dimen_out| procedure computes a |fix_word| relative to the
//! design size. If the data was out of range, it is corrected and the
//! global variable |tfm_changed| is increased by~one.
//!
//! @p function dimen_out(@!x:scaled):integer;
//! begin if abs(x)>max_tfm_dimen then
//!   begin incr(tfm_changed);
//!   if x>0 then x:=max_tfm_dimen@+else x:=-max_tfm_dimen;
//!   end;
//! x:=make_scaled(x*16,internal[design_size]);
//! dimen_out:=x;
//! end;
//!
//! @ @<Glob...@>=
//! @!max_tfm_dimen:scaled; {bound on widths, heights, kerns, etc.}
//! @!tfm_changed:integer; {the number of data entries that were out of bounds}
//!
//! @ If the user has not specified any of the first four header bytes,
//! the |fix_check_sum| procedure replaces them by a ``check sum'' computed
//! from the |tfm_width| data relative to the design size.
//! @^check sum@>
//!
//! @p procedure fix_check_sum;
//! label exit;
//! var @!k:eight_bits; {runs through character codes}
//! @!b1,@!b2,@!b3,@!b4:eight_bits; {bytes of the check sum}
//! @!x:integer; {hash value used in check sum computation}
//! begin if header_byte[1]<0 then if header_byte[2]<0 then
//!   if header_byte[3]<0 then if header_byte[4]<0 then
//!   begin @<Compute a check sum in |(b1,b2,b3,b4)|@>;
//!   header_byte[1]:=b1; header_byte[2]:=b2;
//!   header_byte[3]:=b3; header_byte[4]:=b4; return;
//!   end;
//! for k:=1 to 4 do if header_byte[k]<0 then header_byte[k]:=0;
//! exit:end;
//!
//! @ @<Compute a check sum in |(b1,b2,b3,b4)|@>=
//! b1:=bc; b2:=ec; b3:=bc; b4:=ec; tfm_changed:=0;
//! for k:=bc to ec do if char_exists[k] then
//!   begin x:=dimen_out(value(tfm_width[k]))+(k+4)*@'20000000; {this is positive}
//!   b1:=(b1+b1+x) mod 255;
//!   b2:=(b2+b2+x) mod 253;
//!   b3:=(b3+b3+x) mod 251;
//!   b4:=(b4+b4+x) mod 247;
//!   end
//!
//! @ Finally we're ready to actually write the \.{TFM} information.
//! Here are some utility routines for this purpose.
//!
//! @d tfm_out(#)==write(tfm_file,#) {output one byte to |tfm_file|}
//!
//! @p procedure tfm_two(@!x:integer); {output two bytes to |tfm_file|}
//! begin tfm_out(x div 256); tfm_out(x mod 256);
//! end;
//! @#
//! procedure tfm_four(@!x:integer); {output four bytes to |tfm_file|}
//! begin if x>=0 then tfm_out(x div three_bytes)
//! else  begin x:=x+@'10000000000; {use two's complement for negative values}
//!   x:=x+@'10000000000;
//!   tfm_out((x div three_bytes) + 128);
//!   end;
//! x:=x mod three_bytes; tfm_out(x div unity);
//! x:=x mod unity; tfm_out(x div @'400);
//! tfm_out(x mod @'400);
//! end;
//! @#
//! procedure tfm_qqqq(@!x:four_quarters); {output four quarterwords to |tfm_file|}
//! begin tfm_out(qo(x.b0)); tfm_out(qo(x.b1)); tfm_out(qo(x.b2));
//! tfm_out(qo(x.b3));
//! end;
//!
//! @ @<Finish the \.{TFM} file@>=
//! if job_name=0 then open_log_file;
//! pack_job_name(".tfm");
//! while not b_open_out(tfm_file) do
//!   prompt_file_name("file name for font metrics",".tfm");
//! metric_file_name:=b_make_name_string(tfm_file);
//! @<Output the subfile sizes and header bytes@>;
//! @<Output the character information bytes, then
//!   output the dimensions themselves@>;
//! @<Output the ligature/kern program@>;
//! @<Output the extensible character recipes and the font metric parameters@>;
//! @!stat if internal[tracing_stats]>0 then
//!   @<Log the subfile sizes of the \.{TFM} file@>;@;@+tats@/
//! print_nl("Font metrics written on "); slow_print(metric_file_name);
//! print_char(".");
//! @.Font metrics written...@>
//! b_close(tfm_file)
//!
//! @ Integer variables |lh|, |k|, and |lk_offset| will be defined when we use
//! this code.
//!
//! @<Output the subfile sizes and header bytes@>=
//! k:=header_size;
//! while header_byte[k]<0 do decr(k);
//! lh:=(k+3) div 4; {this is the number of header words}
//! if bc>ec then bc:=1; {if there are no characters, |ec=0| and |bc=1|}
//! @<Compute the ligature/kern program offset and implant the
//!   left boundary label@>;
//! tfm_two(6+lh+(ec-bc+1)+nw+nh+nd+ni+nl+lk_offset+nk+ne+np);
//!   {this is the total number of file words that will be output}
//! tfm_two(lh); tfm_two(bc); tfm_two(ec); tfm_two(nw); tfm_two(nh);
//! tfm_two(nd); tfm_two(ni); tfm_two(nl+lk_offset); tfm_two(nk); tfm_two(ne);
//! tfm_two(np);
//! for k:=1 to 4*lh do
//!   begin if header_byte[k]<0 then header_byte[k]:=0;
//!   tfm_out(header_byte[k]);
//!   end
//!
//! @ @<Output the character information bytes...@>=
//! for k:=bc to ec do
//!   if not char_exists[k] then tfm_four(0)
//!   else  begin tfm_out(info(tfm_width[k])); {the width index}
//!     tfm_out((info(tfm_height[k]))*16+info(tfm_depth[k]));
//!     tfm_out((info(tfm_ital_corr[k]))*4+char_tag[k]);
//!     tfm_out(char_remainder[k]);
//!     end;
//! tfm_changed:=0;
//! for k:=1 to 4 do
//!   begin tfm_four(0); p:=dimen_head[k];
//!   while p<>inf_val do
//!     begin tfm_four(dimen_out(value(p))); p:=link(p);
//!     end;
//!   end
//!
//! @ We need to output special instructions at the beginning of the
//! |lig_kern| array in order to specify the right boundary character
//! and/or to handle starting addresses that exceed 255. The |label_loc|
//! and |label_char| arrays have been set up to record all the
//! starting addresses; we have $-1=|label_loc|[0]<|label_loc|[1]\le\cdots
//! \le|label_loc|[|label_ptr]|$.
//!
//! @<Compute the ligature/kern program offset...@>=
//! bchar:=round_unscaled(internal[boundary_char]);
//! if(bchar<0)or(bchar>255)then
//!   begin bchar:=-1; lk_started:=false; lk_offset:=0;@+end
//! else begin lk_started:=true; lk_offset:=1;@+end;
//! @<Find the minimum |lk_offset| and adjust all remainders@>;
//! if bch_label<undefined_label then
//!   begin skip_byte(nl):=qi(255); next_char(nl):=qi(0);
//!   op_byte(nl):=qi(((bch_label+lk_offset)div 256));
//!   rem_byte(nl):=qi(((bch_label+lk_offset)mod 256));
//!   incr(nl); {possibly |nl=lig_table_size+1|}
//!   end
//!
//! @ @<Find the minimum |lk_offset|...@>=
//! k:=label_ptr; {pointer to the largest unallocated label}
//! if label_loc[k]+lk_offset>255 then
//!   begin lk_offset:=0; lk_started:=false; {location 0 can do double duty}
//!   repeat char_remainder[label_char[k]]:=lk_offset;
//!   while label_loc[k-1]=label_loc[k] do
//!     begin decr(k); char_remainder[label_char[k]]:=lk_offset;
//!     end;
//!   incr(lk_offset); decr(k);
//!   until lk_offset+label_loc[k]<256;
//!     {N.B.: |lk_offset=256| satisfies this when |k=0|}
//!   end;
//! if lk_offset>0 then
//!   while k>0 do
//!     begin char_remainder[label_char[k]]
//!      :=char_remainder[label_char[k]]+lk_offset;
//!     decr(k);
//!     end
//!
//! @ @<Output the ligature/kern program@>=
//! for k:=0 to 255 do if skip_table[k]<undefined_label then
//!   begin print_nl("(local label "); print_int(k); print(":: was missing)");
//! @.local label l:: was missing@>
//!   cancel_skips(skip_table[k]);
//!   end;
//! if lk_started then {|lk_offset=1| for the special |bchar|}
//!   begin tfm_out(255); tfm_out(bchar); tfm_two(0);
//!   end
//! else for k:=1 to lk_offset do {output the redirection specs}
//!   begin ll:=label_loc[label_ptr];
//!   if bchar<0 then
//!     begin tfm_out(254); tfm_out(0);
//!     end
//!   else begin tfm_out(255); tfm_out(bchar);
//!     end;
//!   tfm_two(ll+lk_offset);
//!   repeat decr(label_ptr);
//!   until label_loc[label_ptr]<ll;
//!   end;
//! for k:=0 to nl-1 do tfm_qqqq(lig_kern[k]);
//! for k:=0 to nk-1 do tfm_four(dimen_out(kern[k]))
//!
//! @ @<Output the extensible character recipes...@>=
//! for k:=0 to ne-1 do tfm_qqqq(exten[k]);
//! for k:=1 to np do
//!   if k=1 then
//!     if abs(param[1])<fraction_half then tfm_four(param[1]*16)
//!     else  begin incr(tfm_changed);
//!       if param[1]>0 then tfm_four(el_gordo)
//!       else tfm_four(-el_gordo);
//!       end
//!   else tfm_four(dimen_out(param[k]));
//! if tfm_changed>0 then
//!   begin if tfm_changed=1 then print_nl("(a font metric dimension")
//! @.a font metric dimension...@>
//!   else  begin print_nl("("); print_int(tfm_changed);
//! @.font metric dimensions...@>
//!     print(" font metric dimensions");
//!     end;
//!   print(" had to be decreased)");
//!   end
//!
//! @ @<Log the subfile sizes of the \.{TFM} file@>=
//! begin wlog_ln(' ');
//! if bch_label<undefined_label then decr(nl);
//! wlog_ln('(You used ',nw:1,'w,',@| nh:1,'h,',@| nd:1,'d,',@| ni:1,'i,',@|
//!  nl:1,'l,',@| nk:1,'k,',@| ne:1,'e,',@|
//!  np:1,'p metric file positions');
//! wlog_ln('  out of ',@| '256w,16h,16d,64i,',@|
//!  lig_table_size:1,'l,',max_kerns:1,'k,256e,',@|
//!  max_font_dimen:1,'p)');
//! end
//!
//! @* \[46] Generic font file format.
//! The most important output produced by a typical run of \MF\ is the
//! ``generic font'' (\.{GF}) file that specifies the bit patterns of the
//! characters that have been drawn. The term {\sl generic\/} indicates that
//! this file format doesn't match the conventions of any name-brand manufacturer;
//! but it is easy to convert \.{GF} files to the special format required by
//! almost all digital phototypesetting equipment. There's a strong analogy
//! between the \.{DVI} files written by \TeX\ and the \.{GF} files written
//! by \MF; and, in fact, the file formats have a lot in common.
//!
//! A \.{GF} file is a stream of 8-bit bytes that may be
//! regarded as a series of commands in a machine-like language. The first
//! byte of each command is the operation code, and this code is followed by
//! zero or more bytes that provide parameters to the command. The parameters
//! themselves may consist of several consecutive bytes; for example, the
//! `|boc|' (beginning of character) command has six parameters, each of
//! which is four bytes long. Parameters are usually regarded as nonnegative
//! integers; but four-byte-long parameters can be either positive or
//! negative, hence they range in value from $-2^{31}$ to $2^{31}-1$.
//! As in \.{TFM} files, numbers that occupy
//! more than one byte position appear in BigEndian order,
//! and negative numbers appear in two's complement notation.
//!
//! A \.{GF} file consists of a ``preamble,'' followed by a sequence of one or
//! more ``characters,'' followed by a ``postamble.'' The preamble is simply a
//! |pre| command, with its parameters that introduce the file; this must come
//! first.  Each ``character'' consists of a |boc| command, followed by any
//! number of other commands that specify ``black'' pixels,
//! followed by an |eoc| command. The characters appear in the order that \MF\
//! generated them. If we ignore no-op commands (which are allowed between any
//! two commands in the file), each |eoc| command is immediately followed by a
//! |boc| command, or by a |post| command; in the latter case, there are no
//! more characters in the file, and the remaining bytes form the postamble.
//! Further details about the postamble will be explained later.
//!
//! Some parameters in \.{GF} commands are ``pointers.'' These are four-byte
//! quantities that give the location number of some other byte in the file;
//! the first file byte is number~0, then comes number~1, and so on.
//!
//! @ The \.{GF} format is intended to be both compact and easily interpreted
//! by a machine. Compactness is achieved by making most of the information
//! relative instead of absolute. When a \.{GF}-reading program reads the
//! commands for a character, it keeps track of two quantities: (a)~the current
//! column number,~|m|; and (b)~the current row number,~|n|.  These are 32-bit
//! signed integers, although most actual font formats produced from \.{GF}
//! files will need to curtail this vast range because of practical
//! limitations. (\MF\ output will never allow $\vert m\vert$ or $\vert
//! n\vert$ to get extremely large, but the \.{GF} format tries to be more general.)
//!
//! How do \.{GF}'s row and column numbers correspond to the conventions
//! of \TeX\ and \MF? Well, the ``reference point'' of a character, in \TeX's
//! view, is considered to be at the lower left corner of the pixel in row~0
//! and column~0. This point is the intersection of the baseline with the left
//! edge of the type; it corresponds to location $(0,0)$ in \MF\ programs.
//! Thus the pixel in \.{GF} row~0 and column~0 is \MF's unit square, comprising the
//! region of the plane whose coordinates both lie between 0 and~1. The
//! pixel in \.{GF} row~|n| and column~|m| consists of the points whose \MF\
//! coordinates |(x,y)| satisfy |m<=x<=m+1| and |n<=y<=n+1|.  Negative values of
//! |m| and~|x| correspond to columns of pixels {\sl left\/} of the reference
//! point; negative values of |n| and~|y| correspond to rows of pixels {\sl
//! below\/} the baseline.
//!
//! Besides |m| and |n|, there's also a third aspect of the current
//! state, namely the @!|paint_switch|, which is always either |black| or
//! |white|. Each \\{paint} command advances |m| by a specified amount~|d|,
//! and blackens the intervening pixels if |paint_switch=black|; then
//! the |paint_switch| changes to the opposite state. \.{GF}'s commands are
//! designed so that |m| will never decrease within a row, and |n| will never
//! increase within a character; hence there is no way to whiten a pixel that
//! has been blackened.
//!
//! @ Here is a list of all the commands that may appear in a \.{GF} file. Each
//! command is specified by its symbolic name (e.g., |boc|), its opcode byte
//! (e.g., 67), and its parameters (if any). The parameters are followed
//! by a bracketed number telling how many bytes they occupy; for example,
//! `|d[2]|' means that parameter |d| is two bytes long.
//!
//! \yskip\hang|paint_0| 0. This is a \\{paint} command with |d=0|; it does
//! nothing but change the |paint_switch| from \\{black} to \\{white} or vice~versa.
//!
//! \yskip\hang\\{paint\_1} through \\{paint\_63} (opcodes 1 to 63).
//! These are \\{paint} commands with |d=1| to~63, defined as follows: If
//! |paint_switch=black|, blacken |d|~pixels of the current row~|n|,
//! in columns |m| through |m+d-1| inclusive. Then, in any case,
//! complement the |paint_switch| and advance |m| by~|d|.
//!
//! \yskip\hang|paint1| 64 |d[1]|. This is a \\{paint} command with a specified
//! value of~|d|; \MF\ uses it to paint when |64<=d<256|.
//!
//! \yskip\hang|@!paint2| 65 |d[2]|. Same as |paint1|, but |d|~can be as high
//! as~65535.
//!
//! \yskip\hang|@!paint3| 66 |d[3]|. Same as |paint1|, but |d|~can be as high
//! as $2^{24}-1$. \MF\ never needs this command, and it is hard to imagine
//! anybody making practical use of it; surely a more compact encoding will be
//! desirable when characters can be this large. But the command is there,
//! anyway, just in case.
//!
//! \yskip\hang|boc| 67 |c[4]| |p[4]| |min_m[4]| |max_m[4]| |min_n[4]|
//! |max_n[4]|. Beginning of a character:  Here |c| is the character code, and
//! |p| points to the previous character beginning (if any) for characters having
//! this code number modulo 256.  (The pointer |p| is |-1| if there was no
//! prior character with an equivalent code.) The values of registers |m| and |n|
//! defined by the instructions that follow for this character must
//! satisfy |min_m<=m<=max_m| and |min_n<=n<=max_n|.  (The values of |max_m| and
//! |min_n| need not be the tightest bounds possible.)  When a \.{GF}-reading
//! program sees a |boc|, it can use |min_m|, |max_m|, |min_n|, and |max_n| to
//! initialize the bounds of an array. Then it sets |m:=min_m|, |n:=max_n|, and
//! |paint_switch:=white|.
//!
//! \yskip\hang|boc1| 68 |c[1]| |@!del_m[1]| |max_m[1]| |@!del_n[1]| |max_n[1]|.
//! Same as |boc|, but |p| is assumed to be~$-1$; also |del_m=max_m-min_m|
//! and |del_n=max_n-min_n| are given instead of |min_m| and |min_n|.
//! The one-byte parameters must be between 0 and 255, inclusive.
//! \ (This abbreviated |boc| saves 19~bytes per character, in common cases.)
//!
//! \yskip\hang|eoc| 69. End of character: All pixels blackened so far
//! constitute the pattern for this character. In particular, a completely
//! blank character might have |eoc| immediately following |boc|.
//!
//! \yskip\hang|skip0| 70. Decrease |n| by 1 and set |m:=min_m|,
//! |paint_switch:=white|. \ (This finishes one row and begins another,
//! ready to whiten the leftmost pixel in the new row.)
//!
//! \yskip\hang|skip1| 71 |d[1]|. Decrease |n| by |d+1|, set |m:=min_m|, and set
//! |paint_switch:=white|. This is a way to produce |d| all-white rows.
//!
//! \yskip\hang|@!skip2| 72 |d[2]|. Same as |skip1|, but |d| can be as large
//! as 65535.
//!
//! \yskip\hang|@!skip3| 73 |d[3]|. Same as |skip1|, but |d| can be as large
//! as $2^{24}-1$. \MF\ obviously never needs this command.
//!
//! \yskip\hang|new_row_0| 74. Decrease |n| by 1 and set |m:=min_m|,
//! |paint_switch:=black|. \ (This finishes one row and begins another,
//! ready to {\sl blacken\/} the leftmost pixel in the new row.)
//!
//! \yskip\hang|@!new_row_1| through |@!new_row_164| (opcodes 75 to 238). Same as
//! |new_row_0|, but with |m:=min_m+1| through |min_m+164|, respectively.
//!
//! \yskip\hang|xxx1| 239 |k[1]| |x[k]|. This command is undefined in
//! general; it functions as a $(k+2)$-byte |no_op| unless special \.{GF}-reading
//! programs are being used. \MF\ generates \\{xxx} commands when encountering
//! a \&{special} string; this occurs in the \.{GF} file only between
//! characters, after the preamble, and before the postamble. However,
//! \\{xxx} commands might appear within characters,
//! in \.{GF} files generated by other
//! processors. It is recommended that |x| be a string having the form of a
//! keyword followed by possible parameters relevant to that keyword.
//!
//! \yskip\hang|@!xxx2| 240 |k[2]| |x[k]|. Like |xxx1|, but |0<=k<65536|.
//!
//! \yskip\hang|xxx3| 241 |k[3]| |x[k]|. Like |xxx1|, but |0<=k<@t$2^{24}$@>|.
//! \MF\ uses this when sending a \&{special} string whose length exceeds~255.
//!
//! \yskip\hang|@!xxx4| 242 |k[4]| |x[k]|. Like |xxx1|, but |k| can be
//! ridiculously large; |k| mustn't be negative.
//!
//! \yskip\hang|yyy| 243 |y[4]|. This command is undefined in general;
//! it functions as a 5-byte |no_op| unless special \.{GF}-reading programs
//! are being used. \MF\ puts |scaled| numbers into |yyy|'s, as a
//! result of \&{numspecial} commands; the intent is to provide numeric
//! parameters to \\{xxx} commands that immediately precede.
//!
//! \yskip\hang|@!no_op| 244. No operation, do nothing. Any number of |no_op|'s
//! may occur between \.{GF} commands, but a |no_op| cannot be inserted between
//! a command and its parameters or between two parameters.
//!
//! \yskip\hang|char_loc| 245 |c[1]| |dx[4]| |dy[4]| |w[4]| |p[4]|.
//! This command will appear only in the postamble, which will be explained shortly.
//!
//! \yskip\hang|@!char_loc0| 246 |c[1]| |@!dm[1]| |w[4]| |p[4]|.
//! Same as |char_loc|, except that |dy| is assumed to be zero, and the value
//! of~|dx| is taken to be |65536*dm|, where |0<=dm<256|.
//!
//! \yskip\hang|pre| 247 |i[1]| |k[1]| |x[k]|.
//! Beginning of the preamble; this must come at the very beginning of the
//! file. Parameter |i| is an identifying number for \.{GF} format, currently
//! 131. The other information is merely commentary; it is not given
//! special interpretation like \\{xxx} commands are. (Note that \\{xxx}
//! commands may immediately follow the preamble, before the first |boc|.)
//!
//! \yskip\hang|post| 248. Beginning of the postamble, see below.
//!
//! \yskip\hang|post_post| 249. Ending of the postamble, see below.
//!
//! \yskip\noindent Commands 250--255 are undefined at the present time.
//!
//! @d gf_id_byte=131 {identifies the kind of \.{GF} files described here}
//!
//! @ \MF\ refers to the following opcodes explicitly.
//!
//! @d paint_0=0 {beginning of the \\{paint} commands}
//! @d paint1=64 {move right a given number of columns, then
//!   black${}\swap{}$white}
//! @d boc=67 {beginning of a character}
//! @d boc1=68 {short form of |boc|}
//! @d eoc=69 {end of a character}
//! @d skip0=70 {skip no blank rows}
//! @d skip1=71 {skip over blank rows}
//! @d new_row_0=74 {move down one row and then right}
//! @d max_new_row=164 {the largest \\{new\_row} command is |new_row_164|}
//! @d xxx1=239 {for \&{special} strings}
//! @d xxx3=241 {for long \&{special} strings}
//! @d yyy=243 {for \&{numspecial} numbers}
//! @d char_loc=245 {character locators in the postamble}
//! @d pre=247 {preamble}
//! @d post=248 {postamble beginning}
//! @d post_post=249 {postamble ending}
//!
//! @ The last character in a \.{GF} file is followed by `|post|'; this command
//! introduces the postamble, which summarizes important facts that \MF\ has
//! accumulated. The postamble has the form
//! $$\vbox{\halign{\hbox{#\hfil}\cr
//!   |post| |p[4]| |@!ds[4]| |@!cs[4]| |@!hppp[4]| |@!vppp[4]|
//!    |@!min_m[4]| |@!max_m[4]| |@!min_n[4]| |@!max_n[4]|\cr
//!   $\langle\,$character locators$\,\rangle$\cr
//!   |post_post| |q[4]| |i[1]| 223's$[{\G}4]$\cr}}$$
//! Here |p| is a pointer to the byte following the final |eoc| in the file
//! (or to the byte following the preamble, if there are no characters);
//! it can be used to locate the beginning of \\{xxx} commands
//! that might have preceded the postamble. The |ds| and |cs| parameters
//! @^design size@> @^check sum@>
//! give the design size and check sum, respectively, which are exactly the
//! values put into the header of the \.{TFM} file that \MF\ produces (or
//! would produce) on this run. Parameters |hppp| and |vppp| are the ratios of
//! pixels per point, horizontally and vertically, expressed as |scaled| integers
//! (i.e., multiplied by $2^{16}$); they can be used to correlate the font
//! with specific device resolutions, magnifications, and ``at sizes.''  Then
//! come |min_m|, |max_m|, |min_n|, and |max_n|, which bound the values that
//! registers |m| and~|n| assume in all characters in this \.{GF} file.
//! (These bounds need not be the best possible; |max_m| and |min_n| may, on the
//! other hand, be tighter than the similar bounds in |boc| commands. For
//! example, some character may have |min_n=-100| in its |boc|, but it might
//! turn out that |n| never gets lower than |-50| in any character; then
//! |min_n| can have any value |<=-50|. If there are no characters in the file,
//! it's possible to have |min_m>max_m| and/or |min_n>max_n|.)
//!
//! @ Character locators are introduced by |char_loc| commands,
//! which specify a character residue~|c|, character escapements (|dx,dy|),
//! a character width~|w|, and a pointer~|p|
//! to the beginning of that character. (If two or more characters have the
//! same code~|c| modulo 256, only the last will be indicated; the others can be
//! located by following backpointers. Characters whose codes differ by a
//! multiple of 256 are assumed to share the same font metric information,
//! hence the \.{TFM} file contains only residues of character codes modulo~256.
//! This convention is intended for oriental languages, when there are many
//! character shapes but few distinct widths.)
//! @^oriental characters@>@^Chinese characters@>@^Japanese characters@>
//!
//! The character escapements (|dx,dy|) are the values of \MF's \&{chardx}
//! and \&{chardy} parameters; they are in units of |scaled| pixels;
//! i.e., |dx| is in horizontal pixel units times $2^{16}$, and |dy| is in
//! vertical pixel units times $2^{16}$.  This is the intended amount of
//! displacement after typesetting the character; for \.{DVI} files, |dy|
//! should be zero, but other document file formats allow nonzero vertical
//! escapement.
//!
//! The character width~|w| duplicates the information in the \.{TFM} file; it
//! is a |fix_word| value relative to the design size, and it should be
//! independent of magnification.
//!
//! The backpointer |p| points to the character's |boc|, or to the first of
//! a sequence of consecutive \\{xxx} or |yyy| or |no_op| commands that
//! immediately precede the |boc|, if such commands exist; such ``special''
//! commands essentially belong to the characters, while the special commands
//! after the final character belong to the postamble (i.e., to the font
//! as a whole). This convention about |p| applies also to the backpointers
//! in |boc| commands, even though it wasn't explained in the description
//! of~|boc|. @^backpointers@>
//!
//! Pointer |p| might be |-1| if the character exists in the \.{TFM} file
//! but not in the \.{GF} file. This unusual situation can arise in \MF\ output
//! if the user had |proofing<0| when the character was being shipped out,
//! but then made |proofing>=0| in order to get a \.{GF} file.
//!
//! @ The last part of the postamble, following the |post_post| byte that
//! signifies the end of the character locators, contains |q|, a pointer to the
//! |post| command that started the postamble.  An identification byte, |i|,
//! comes next; this currently equals~131, as in the preamble.
//!
//! The |i| byte is followed by four or more bytes that are all equal to
//! the decimal number 223 (i.e., @'337 in octal). \MF\ puts out four to seven of
//! these trailing bytes, until the total length of the file is a multiple of
//! four bytes, since this works out best on machines that pack four bytes per
//! word; but any number of 223's is allowed, as long as there are at least four
//! of them. In effect, 223 is a sort of signature that is added at the very end.
//! @^Fuchs, David Raymond@>
//!
//! This curious way to finish off a \.{GF} file makes it feasible for
//! \.{GF}-reading programs to find the postamble first, on most computers,
//! even though \MF\ wants to write the postamble last. Most operating
//! systems permit random access to individual words or bytes of a file, so
//! the \.{GF} reader can start at the end and skip backwards over the 223's
//! until finding the identification byte. Then it can back up four bytes, read
//! |q|, and move to byte |q| of the file. This byte should, of course,
//! contain the value 248 (|post|); now the postamble can be read, so the
//! \.{GF} reader can discover all the information needed for individual characters.
//!
//! Unfortunately, however, standard \PASCAL\ does not include the ability to
//! @^system dependencies@>
//! access a random position in a file, or even to determine the length of a file.
//! Almost all systems nowadays provide the necessary capabilities, so \.{GF}
//! format has been designed to work most efficiently with modern operating systems.
//! But if \.{GF} files have to be processed under the restrictions of standard
//! \PASCAL, one can simply read them from front to back. This will
//! be adequate for most applications. However, the postamble-first approach
//! would facilitate a program that merges two \.{GF} files, replacing data
//! from one that is overridden by corresponding data in the other.
//!
